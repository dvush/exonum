// Copyright 2018 The Exonum Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// spell-checker:ignore walkdir, subfolders, submodules

//! This crate simplifies writing build.rs for exonum and exonum services.

extern crate protoc_rust;
extern crate walkdir;

use protoc_rust::Customize;
use walkdir::WalkDir;

use std::{env, fs::File, io::Write, path::Path};

/// Find all .proto files in `path` and subfolders.
fn get_proto_files<P: AsRef<Path>>(path: P) -> Vec<String> {
    WalkDir::new(path)
        .into_iter()
        .filter_map(|e| {
            let e = e.ok()?;
            if e.path().extension()?.to_str() == Some("proto") {
                Some(e.path().to_str()?.to_owned())
            } else {
                None
            }
        }).collect()
}

/// Workaround for https://github.com/stepancheg/rust-protobuf/issues/324
/// It is impossible to `include!` .rs files generated by rust-protobuf
/// so we generate piece of `mod.rs` which includes generated files as public submodules.
///
/// tests.proto .rs file will be included with `#[cfg(test)]`.
fn generate_mod_rs(out_dir: &str, proto_files: &[String], mod_file: &str) {
    let mod_file_content = {
        proto_files
            .iter()
            .map(|f| {
                let mod_name = Path::new(f)
                    .file_stem()
                    .unwrap()
                    .to_str()
                    .expect("proto file name is not &str");
                if mod_name == "tests" {
                    format!("#[cfg(test)]\npub mod {};\n", mod_name)
                } else {
                    format!("pub mod {};\n", mod_name)
                }
            }).collect::<String>()
    };
    let dest_path = Path::new(&out_dir).join(mod_file);
    let mut file = File::create(dest_path).expect("Unable to create output file");
    file.write_all(mod_file_content.as_bytes())
        .expect("Unable to write data to file");
}

/// Generate .rs files from .proto files.
///
/// `protoc` executable from protobuf should be in `$PATH`
///
/// # Examples
///
/// ```no_run
/// // In build.rs
/// extern crate exonum_build;
///
/// use exonum_build::protobuf_generate;
///
/// // Includes usually should contain input_dir.
/// protobuf_generate("src/proto", &["src/proto"], "example_mod.rs")
/// ```
/// After successful run `$OUT_DIR` will contain \*.rs for each \*.proto file in
/// "src/proto/\*\*/" and example_mod.rs which will include all generated .rs files
/// as submodules.
///
/// To use generated protobuf structs.
///
/// ```ignore
/// // In src/proto/mod.rs
/// extern crate exonum;
///
/// include!(concat!(env!("OUT_DIR"), "/example_mod.rs"));
///
/// // If you use types from exonum .proto files.
/// use exonum::encoding::protobuf::*;
/// ```
pub fn protobuf_generate(input_dir: &str, includes: &[&str], mod_file: &str) {
    let out_dir = &env::var("OUT_DIR").expect("Unable to get OUT_DIR");

    let proto_files = get_proto_files(input_dir);

    generate_mod_rs(out_dir, &proto_files, mod_file);

    protoc_rust::run(protoc_rust::Args {
        out_dir,
        input: &proto_files.iter().map(|s| s.as_ref()).collect::<Vec<_>>(),
        includes,
        customize: Customize {
            serde_derive: Some(true),
            ..Default::default()
        },
    }).expect("protoc");

    // rerun build.rs if .proto files changed.
    println!("cargo:rerun-if-changed={}", input_dir);
}
